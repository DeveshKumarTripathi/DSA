// DP Recursive Method - Memoization

// class Solution {

//     public int minPathSum(int[][] grid) {
//         int n = grid.length;
//         int m = grid[0].length;

//         int[][] dp = new int[n][m];
//         for (int[] row : dp) Arrays.fill(row, -1);

//         return solve(grid, 0, 0, dp);
//     }

//     static int solve(int[][] grid, int i, int j, int[][] dp) {
//         int n = grid.length;
//         int m = grid[0].length;

//         if (i == n - 1 && j == m - 1) {
//             return grid[i][j];
//         }

//         if (dp[i][j] != -1) return dp[i][j];

//         if (i == n - 1) {
//             return dp[i][j] = grid[i][j] + solve(grid, i, j + 1, dp);
//         }

//         if (j == m - 1) {
//             return dp[i][j] = grid[i][j] + solve(grid, i + 1, j, dp);
//         }

//         int down = solve(grid, i + 1, j, dp);
//         int right = solve(grid, i, j + 1, dp);

//         return dp[i][j] = grid[i][j] + Math.min(down, right);
//     }
// }


// DP - Tabulation

class Solution {
    public int minPathSum(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        int[][] dp = new int[n][m];
        dp[n-1][m-1] = grid[n-1][m-1];

        for(int i = m-2; i>=0; i--){
            dp[n-1][i] = grid[n-1][i] + dp[n-1][i+1];
        } 
        for(int i = n-2; i>=0; i--){
            dp[i][m-1] = grid[i][m-1] + dp[i+1][m-1];
        } 
        for(int i = n - 2; i >= 0; i--){
            for(int j = m - 2; j>= 0; j--){
                dp[i][j] = grid[i][j] + Math.min(dp[i+1][j], dp[i][j+1]);
            }
        }
        return dp[0][0];
    }
}

